# -*- coding: utf-8 -*-
"""Minu Choi DS - Data Management/Manipulation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_I-2zSOnZxoIbSjYFSCC3XbKqCSfqHfX

1.  Load the following dataset into Colab and perform the requested operations in code.

 Source: https://ds1002-resources.s3.amazonaws.com/data/ride_sharing.csv
"""

# Load pandas and the data
import pandas as pd
ride = pd.read_csv('ride_sharing.csv')
ride

# show how many rows and columns are in this dataset
ride.shape
print(f'Number of rows: {ride.shape[0]}')
print(f'Number of columns:{ride.shape[1]}')

# The first column, "duration" is seen as a string.
# Using two snippets of code, clean this column up so that
# is now an integer (int64)

ride['duration'] = ride['duration'].str.replace(' minutes', '')
ride['duration'] = ride['duration'].astype('int')

# Now display the datatypes in the updated dataframe
print(ride.dtypes)

# Show the min and max values of ride durations (the shortest and longest rides)
# Hint: If 'df' is the name of your dataframe, simply specify the column name
# and then append the .min() or .max() methods.

min_duration = ride['duration'].min()
max_duration = ride['duration'].max()

print(f'The shortest ride duration is {min_duration} minute.')
print(f'The longest ride duration is {max_duration} minutes.')

# Create a new dataframe object and populate it with rides that are 60 minutes or less.
# Hint: Use the .query() method for the dataframe that we used in class.

shortride = ride.query('duration <= 60')
shortride

# Now show both the min and max values of the duration column for your new dataset.
shortride_min_duration = shortride['duration'].min()
shortride_max_duration = shortride['duration'].max()

print(f'The shortest ride duration is {shortride_min_duration} minute.')
print(f'The longest ride duration is {shortride_max_duration} minutes.')

# Using the new dataframe, update it so that is ONLY has records where
# the tire_size is 26.

shortride = shortride[shortride['tire_size'] == 26]
shortride

# Finally, produce a count of all records with FEMALE riders
# using the 26-inch wheeled rental bikes for their rentals of
# one hour or less.

female_riders = sum(shortride['user_gender'] == 'Female')

print(f'The numer of female riders using the 26-inch tires for one hour or less is {female_riders}.')

"""2. Find the file `more-messy-data.csv` on Canvas and upload it into Google Colab.

Create a new Pandas DataFrame from that data and perform the following steps.
"""

#loading the more-messy-data
messy = pd.read_csv('more-messy-data.csv')
messy

# Write a snippet of code that will display the number of duplicate rows exist in the DF.
print(messy.duplicated().sum())

# Next, remove all duplicate rows using Python.
messy = messy.drop_duplicates()
# I will print the number of duplicate rows in order to verify that the output is 0.
print(messy.duplicated().sum())

# For the FOUR columns involving sepal and petal length and width, update all NaN
# values with the column mean.

# In my first attempt, I found that the data type for the columns 'sepal_length', 'sepal_width', 'petal_length'
# was float while 'petal_width' was an object. This prevented me from implementing numeric operations such as mean().


# I first created a list of columns that I aim to fill in NaN values with the mean of the column.
newcolumns = ['sepal_length', 'sepal_width', 'petal_length', 'petal_width']

# I initiated a for loop where for each column, I use pd.to_numeric() to convert the values in that column
# to a numeric type. The 'errors='coerce' that I learned in class, treats values that can't be converted
# to a number as NaN. This ensures that all columns will be numeric.
for column in newcolumns:
    messy[column] = pd.to_numeric(messy[column], errors='coerce')

for column in newcolumns:
    messy[column] = messy[column].fillna(messy[column].mean())

messy[newcolumns]

# Find any values in the dataframe that are still missing, and delete them.

messy_complete = messy.dropna()
messy_complete

# How many different species are there?

# I decided to convert the 'species' column to a set as it  eliminates any duplicate elements.
# This set would then only contain unique elements.
species = set(messy_complete['species'])
number_of_species = len(species)
print(f"There are {number_of_species} different species.")

# Clean up the 'species' variable so that there are exactly three different values.

# I will tackle this problem using a three step process.

# 1. Firstly, I will identify the unique 10 species. This is to understand which variations need to be corrected.
print(messy_complete['species'].unique())

# 2. Now that I have identified all the unique species names, I will replace each
# variation to one of the three: "Virginica", "Setosa", or "Versicolor"
# I will do this using a dictionary and the replace() function

replacements = {
    'virginica':'Virginica',
    'setosa':'Setosa',
    'setoso':'Setosa',
    'Viginica':'Virginica',
    'Virginia':'Virginica',
    'Setosan':'Setosa',
    'versicolor':'Versicolor'
}
messy_complete['species'] = messy_complete['species'].replace(replacements)

#3 The last step is a repetition of step 1 which verifies that there are only three unique species.
print(messy_complete['species'].unique())

"""3. Bonus:  Regular expressions

Ordinary (non-vanity) Virginia license plates have the form `ABC1234`, meaning they have three upper case letters followed by four digits.  Write a regular expression that matches any string of this form (and doesn't match anything else).  Test your expression with code to make sure it works.

To figure out out how to do this, start with the sample code below.  The `re` package has various functions related to regular expressions, including for example `match()`, which takes two arguments, first the regular expression and second the test string, and tests to see whether the *beginning* of the `test` string matches the pattern `exp`.

Note that `re.match(exp,test)` does not return a boolean variable, as you might expect (in other words, a match doesn't return `True` and a non-match `False`).  The type of object you get is called `re.Match`, which is a data type special to the `re` package.  (The reason for this is that the object contains more information than just whether there is a match or not.) However, you can turn it into a boolean using `bool()` if you want.

Include the following in the notebook you submit:

 1. A regular expression in a text chunk
 2. One or more code chunks in which you test several strings to verify that your regex is correct.
 3. Make sure you display the results of testing various strings.

 See this [documentation page](https://docs.python.org/3/howto/regex.html#regex-howto) for further help.
"""

# Sample code for testing whether a string matches a regex

# First import this package for working with regular expressions
import re

# Here is an example.
# Play around with different expressions and test strings to see what happens.
exp = 'ab+'
test = 'aabbbc'

if re.match(exp,test):
  print("match!")
else:
  print("no match")

# uncomment this line if you want
# print(type(re.match(exp,test)))

# uncomment this line if you want
# print(bool(re.match(exp,test)))