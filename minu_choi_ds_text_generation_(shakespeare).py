# -*- coding: utf-8 -*-
"""Minu Choi DS - Text Generation (Shakespeare)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nduypnirfTkQ61yNHWEyJnPpbM-hKDPc

We begin by loading all of Shakespeare's plays into a text file, and separating them into individual words.  This is made easy by the fact that someone already made a giant text file of these plays for us, and put it online.

[Note that by changing the url in the following code chunk, you can load any text file that lives online in this way . . . see below.]

Run the following code.  It should output a list of ten words, starting with 'From' and ending with 'rose'.
"""

from urllib.request import urlopen            #package for reading info from the web
url='https://ocw.mit.edu/ans7870/6/6.006/s08/lecturenotes/files/t8.shakespeare.txt'   #web address
text = urlopen(url).read().decode('utf-8')    #open web address, read file, convert to text
shakespeare_words=text.split()[1651:]         #split text into words (not including preamble)
shakespeare_words[:10]                        #display the first 10 words

"""## 1. `nextwords` practice

Create a practice function called `createNextwordsPractice` which takes a list of words called `wordlist` and returns a dictionary called `nextwordsPractice`. The keys of `nextwordsPractice` should be all the words in `wordlist`, and the value for any given key should be a list of all the words that follow the key word somewhere in the original `wordlist`.


"""

def createNextwordsPractice(wordlist):
  nextwordsPractice = {}
# - 1 because the function accesses the next word. Acessing the end of the list would return an index error on the final iteration.
  for i in range(len(wordlist) - 1):
    current = wordlist[i]
    next = wordlist[i + 1]
    if current in nextwordsPractice:
# If current is a key in the dictionary, the next one is appended to the list that is connected with the current in the dictionary.
      nextwordsPractice[current].append(next)
    else:
      nextwordsPractice[current] = [next]
  return nextwordsPractice

"""Run the following code:"""

practice = createNextwordsPractice(shakespeare_words)
practice['From']

practice['rose']

practice['rose.']

"""## 2. `nextwords` for real:  new sentences.

Next, write a new function called `createNextwords` which takes a `wordlist` and returns a dictionary of `nextwords`, but now with a new additional feature.  
In addition to the keys from problem 1, add a special key to the dictionary, which will be the symbol '%'.  This key will signify the first word of a sentence. When scanning the wordlist to construct the `nextwords` dictionary, normally you would add `wordlist[i+1]` to the list `nextwords[wordlist[i]]`. However, if `wordlist[i]` ends with a period, then you should instead add `wordlist[i+1]` to the list nextwords['%']. Also add the very first word of `wordlist` to nextwords['%'].


You should be able to produce this output:
```
> shakespeare_nextwords=createNextwords(shakespeare_words)
> shakespeare_nextwords['Rose']
['at', 'or', 'or', 'and']

> shakespeare_nextwords['rose.']
[]

> len(shakespeare_nextwords['%'])
76543
```
"""

def createNextwords(wordlist):
  nextwords = {}
  if wordlist:
    nextwords['%'] = [wordlist[0]]

  for i in range(len(wordlist) - 1):
    current = wordlist[i]
    next = wordlist[i + 1]
# The following checks if the current word ends with a period which would be the end of a sentence.
# If the current word ends a sentence, the next one is appended to the words under the key '%', which would be the start of sentences.
    if current.endswith('.'):
      if '%' in nextwords:
        nextwords['%'].append(next)
      else:
        nextwords['%'] = [next]
# If the current does not end a sentence, it will check if the current is already a key in 'nextwords.'
# If the current is a key, the next one is appended to the existing list.
    else:
      if current in nextwords:
        nextwords[current].append(next)
      else:
        nextwords[current] = [next]
# This last if statment checks for whether the last word ends with a period.
# If it does, and if for some reason '%' is not in the dictionary, an empty list will be assigned to '%'.
  if wordlist and wordlist[-1].endswith('.'):
    if '%' not in nextwords:
      nextwords['%'] = []

  return nextwords

"""Run the following code:"""

shakespeare_nextwords = createNextwords(shakespeare_words)

print(shakespeare_nextwords['Rose'])
print(len(shakespeare_nextwords['%']))

print(len(shakespeare_nextwords['rose']))

print(shakespeare_nextwords['rose.'])
# I have tried troubleshooting the 'createNextwords' function but unfortunately, I have not been successfull with this print statement.

"""## 3.  Make your own Shakespeare play

Okay, that may be a bit of an exaggeration.  Anyway, next up is text generation.  
We'll need the choice function:
"""

from random import choice

"""This function chooses a random element from a list.  Run this code a few times:"""

choice([1, 17, 34, 289])

"""Now, create a function called `makePlay(nextwords,n)` which takes a dictionary `nextwords` and a number `n`, and follows these steps:
1. Define an empty `newplay` string.  (I did this for you.)
2. Set `currentword` equal to '%'.
3. Start a for-loop that will run `n` times.
4. Randomly choose a word from the list `nextwords[currentword]`.
5. Add the chosen word to `newplay`, followed by a space `' '` character.
6. If the chosen word ends in a period, add a newline character '\n' and set `currentword` equal to `%`.
7. Otherwise, set `currentword` equal to the chosen word.
8. Go back to step 4.
9. When all `n` iterations have finished, your function should return `newplay`.
"""

def makePlay(nextwords, n):
  newplay = ''
  currentword = '%'
# The for loop will be activated n times with each iteration being able to add a word to newplay.
  for _ in range(n):
# This will check for the currentword being a valid key in nextwords. It will also check if there are any other available for such key.
# If true, the 'chosen_word' is randomly selected from the list of words associated with currentword.
# The chosen_word is then appended to newplay and a space.
    if currentword in nextwords and nextwords[currentword]:
      chosen_word = choice(nextwords[currentword])
      newplay += chosen_word + ' '
# This if statement will check that a chosen_word ends with a period.
# If a sentence ends due to a period, \n is added to start a new line.
# The currentword is reset to '%' to signal a new sentence in the next iteration.
      if chosen_word.endswith('.'):
        newplay += '\n'
        currentword = '%'
      else:
        currentword = chosen_word
    else:
      currentword = '%'

  return newplay

"""Now create a 1000 word Shakesperian play by running the following code:"""

nextwords=createNextwords(shakespeare_words)
newplay=makePlay(nextwords,1000)
print(newplay)

"""At this point you might enjoy finding other sources of text on the internet and replacing the url at the top of this notebook. You can use song lyrics, news articles, etc. You just need to find files ending with '.txt'. Alternatively, you can copy and paste any block of text from any file into colab, assign it to the variable `text`, and then use wordlist=text.split() to get a list of words.

## Bonus:

Recall the following recursive function that we used to define the Fibonacci numbers:
"""

def fibonacci(n):
  # Base cases: F(0) = 0, F(1) = 1
  if n == 0:
    return 0
  elif n == 1:
    return 1
  else:
    # Recursive case: F(n) = F(n-1) + F(n-2)
    return fibonacci(n - 1) + fibonacci(n - 2)

"""Here is the question.  If you run this line of code:  
`fibonacci(17)`  
how many times does the function `fibonacci()` get called?  
(The answer is not 1597, which is the value returned by the function.)

fibonacci(0) and fibonacci(1) are called once.
fibonacci(2) calls fibonacci(1) and fibonacci(0), which are 3 calls in total.
fibonacci(3) calls fibonacci(2) and fibonacci(1), which are 5 calls in total as fibonacci(2) calls the function 3 times.

If we visualize this pattern in a formula, it is the following: C(n)=C(n−1)+C(n−2)+1

C(2)=C(1)+C(0)+1=1+1+1=3

C(3)=C(2)+C(1)+1=3+1+1=5

C(4)=C(3)+C(2)+1=5+3+1=9

C(5)=C(4)+C(3)+1=9+5+1=15

C(6)=C(5)+C(4)+1=15+9+1=25

Running this calculation until C(17) gets us 5167.
"""